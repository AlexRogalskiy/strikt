package strikt.opentest4j

import org.opentest4j.AssertionFailedError
import org.opentest4j.MultipleFailuresError
import org.opentest4j.TestSkippedException
import strikt.api.Status.Failed
import strikt.api.Status.Pending
import strikt.api.reporting.Reportable
import strikt.api.reporting.Result
import strikt.api.reporting.Subject
import strikt.api.reporting.formatValue

/**
 * Throws an exception if the overall assertion is has failed.
 */
internal fun Reportable.throwOnFailure() {
  root.toError()?.let { throw it }
}

/**
 * Converts Strikt's model of an assertion result graph into an opentest4j
 * exception.
 */
internal fun Reportable.toError(): Throwable? {
  return when (this) {
    is Result -> {
      when (status) {
        Failed -> if (results.isEmpty()) {
          AssertionFailedError(toMessage(), expected, actual, cause)
        } else {
          MultipleFailuresError(toMessage(), results.toErrors())
        }
        Pending -> TestSkippedException(toMessage(), cause)
        else -> null
      }
    }
    is Subject<*> ->
      when (status) {
        Failed -> MultipleFailuresError(
          toMessage(),
          results.toErrors()
        )
        Pending -> TestSkippedException(toMessage())
        else -> null
      }
  }
}

private fun Iterable<Reportable>.toErrors() =
  mapNotNull { it.toError() }

private fun Result.toMessage(): String {
  var formattedExpected = formatValue(expected)
  var formattedActual = formatValue(actual)
  if (formattedExpected.toString() == formattedActual.toString()) {
    formattedExpected = formattedExpected.withTypeSuffix(expected)
    formattedActual = formattedActual.withTypeSuffix(actual)
  }
  return description.format(formattedExpected, formattedActual) +
    (message?.let { " : " + it.format(formattedActual) } ?: "")
}

private fun Subject<*>.toMessage() =
  "Expect that: ${description.format(formatValue(value))}"

private fun Any?.withTypeSuffix(originalValue: Any?): String {
  val typeName = originalValue?.let {
    it.javaClass.kotlin.let { type ->
      if (type.qualifiedName?.substringBeforeLast(".") in listOf("kotlin", "java.lang")) {
        type.simpleName
      } else {
        type.qualifiedName
      }
    }
  }
  return "$this ($typeName)"
}
